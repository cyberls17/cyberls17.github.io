---
layout: post
title: "FTZ level12 풀이"
author: "cyberls17"
---

# FTZ level12 풀이

## 홈 디렉토리 및 힌트 확인
![ftz_level12_home_list](/images\ftz_level12_home_list.PNG)<br>
FTZ level12의 홈 디렉토리에 있는 파일들이다.<br>
Setuid가 걸려있는 attackme 파일과 level12의 힌트 파일이 보인다.<br>

![ftz_level12_cat_hint](/images\ftz_level12_cat_hint.PNG)<br>

hint 파일의 내용이다.<br>
C 소스 코드가 나오는데 이 코드를 해석해보면

> char str[256]; #문자형인 str배열의 크기를 256byte로 지정<br>
<br>
setreuid( 3093, 3093 ); #setuid를 level13의 사용자 ID로 설정<br>
printf( "문장을 입력하세요.\n" ); #"문장을 입력하세요" 라는 문자열 출력<br>
gets( str ); #gets 함수로 str 변수에 사용자가 입력한 값을 받는다.<br>
printf( "%s\n", str ); #str 변수에 입력받은 내용 출력<br>

gets 함수는 엔터가 입력되기 전까지 입력된 문자열을 버퍼에 저장하는 함수이다.<br>
gets 함수에도 strcpy 함수처럼 취약점이 존재하는데 그 취약점은 **엔터가 입력될 때까지 입력된 문자열을 버퍼에 저장하는 함수이기 때문에 버퍼의 크기보다 더 큰 문자열이 들어가면 overflow가 발생하는 것**이 취약점이다.<br>

그리고 level11과 마찬가지로 입력 받는 문자의 크기가 str 배열의 크기인 256byte를 넘었을때에 관련된 코드가 없다.<br>
이를 이용하여 Return address를 변조할 수 있다는 것을 알수 있었다.<br>

attackme 프로그램에는 level13 권한의 setuid가 설정되어 있다. 이 프로그램이 실행되는 동안에 my-pass나 /bin/bash 등을 실행시키면 level12의 패스워드를 획득 할 수 있다.<br>

그럼 일단 str[256]의 시작점에서 main() ret 까지의 거리를 먼저 구해보도록 하자.

먼저 디버깅을 위해 attackme 파일을 tmp 디렉토리로 복사하고 gdb로 열어서 intel문법으로 설정해준뒤 gdb로 디버깅을 해보자<br>

>gdb -q attackme<br>
set disas intel<br>
disas main<br>

![ftz_level]

